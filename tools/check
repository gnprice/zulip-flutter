#!/usr/bin/env bash

# Careful! `set -e` doesn't do everything you'd think it does. In
# fact, we don't get its benefit in any of the `run_foo` functions.
#
# This is because it has an effect only when it can exit the whole shell.
# (Its full name is `set -o errexit`, and it means "exit" literally.)  See:
#   https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin
#
# When one test suite fails, we want to go on to run the other suites, so
# we use `||` to prevent the whole script from exiting there, and that
# defeats `set -e`.
#
# For now our workaround is to put `|| return` in the `run_foo` just
# after each nontrivial command that isn't the final command in the
# function.
set -euo pipefail

this_dir=${BASH_SOURCE[0]%/*}

## CLI PARSING

default_suites=(analyze flutter_test build_runner drift)
extra_suites=(
)

usage() {
    cat >&2 <<EOF
usage: tools/check [SUITE]...

Run our tests.

By default, run ${#default_suites[@]} suite(s):
  ${default_suites[*]}
and skip ${#extra_suites[@]} suite(s):
  ${extra_suites[*]}
EOF
    exit 2
}

opt_fix=
opt_suites=()
while (( $# )); do
    case "$1" in
        --fix) opt_fix=1; shift;;
        analyze|flutter_test|build_runner|drift)
            opt_suites+=("$1"); shift;;
        *) usage;;
    esac
done

if (( ! "${#opt_suites[@]}" )); then
    opt_suites=( "${default_suites[@]}" )
fi


## EXECUTION

rootdir=$(git rev-parse --show-toplevel)
cd "$rootdir"

. tools/lib/git.sh

run_analyze() {
    flutter analyze
}

run_flutter_test() {
    flutter test
}

run_build_runner() {
    # build_runner has a --verbose, but lacks a --quiet.
    # So we filter out "[INFO]" messages ourselves.
    dart run build_runner build --delete-conflicting-outputs \
    | perl -lne '
        BEGIN { my $silence = 0 }
        if (/^\[INFO\]/) { $silence = 1 }
        elsif (/^\[[A-Z]/) { $silence = 0 }
        print if (!$silence)
      '
}

run_drift() {
    local schema_dir=test/model/schemas/

    if ! no_uncommitted_changes "${schema_dir}"; then
        echo >&2 "There are uncommitted changes in ${schema_dir}.  Aborting, to avoid losing your work."
        return 1
    fi
    if ! no_untracked_files "${schema_dir}"; then
        echo >&2 "There are untracked files in ${schema_dir}:"
        echo >&2
        git_status_short "${schema_dir}"
        echo >&2
        echo >&2 "Aborting, to avoid losing your work."
        return 1
    fi

    dart run drift_dev schema dump \
        lib/model/database.dart "${schema_dir}" \
    || return
    dart run drift_dev schema generate --data-classes --companions \
        "${schema_dir}" "${schema_dir}" \
    || return

    if git diff --quiet -- "${schema_dir}" \
            && no_untracked_files "${schema_dir}"; then
        return
    fi

    if [ -n "${opt_fix}" ]; then
        echo >&2 "There were schema updates:"
        git_status_short "${schema_dir}"
    else
        git_status_short "${schema_dir}"
        echo >&2 "Error: fresh drift_dev run didn't match existing schemas"
        git checkout HEAD -- "${schema_dir}"
        git clean -fd -- "${schema_dir}"
        return 1
    fi
}

failed=()
for suite in "${opt_suites[@]}"; do
    echo "Running $suite..."
    case "$suite" in
        analyze)      run_analyze ;;
        flutter_test) run_flutter_test ;;
        build_runner) run_build_runner ;;
        drift)        run_drift ;;
    esac || failed+=($suite)
done

if (( ${#failed[@]} )); then
    cat >&2 <<EOF

FAILED: ${failed[*]}

To rerun the suites that failed, run:
  $ tools/test ${failed[*]}
EOF
    exit 1
fi

echo "Passed!"
